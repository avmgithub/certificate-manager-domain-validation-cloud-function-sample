const {promisify} = require('bluebird');
let request = promisify(require('request'));
request = request.defaults({json: true});
const jwtVerify = promisify(require('jsonwebtoken').verify);
const jwtDecode = require('jsonwebtoken').decode;
const softlayerBaseurl = "https://api.softlayer.com/rest/v3";


/**
 * Get the public key used to verify that the notification payload is generated by your Certificate Manager instance.
 * @param body Object
 * @param certificateManagerApiUrl
 * @returns {Promise<publicKey>}
 */
async function getPublicKey(body, certificateManagerApiUrl) {
    console.log(`Get public key for instance ${body.instance_crn}`);
    const keysOptions = {
        method: 'GET',
        url: `${certificateManagerApiUrl}/api/v1/instances/${encodeURIComponent(body.instance_crn)}/notifications/publicKey?keyFormat=pem`,
        headers: {'cache-control': 'no-cache'}
    };

    let response;
    try {
        response = await request(keysOptions);
    }
    catch (err) {
        console.log(`Couldn't get the public key for instance ${body.instance_crn}. Reason is: ${getErrorString(err)}`);
        throw new Error(`Couldn't get the public key for instance ${body.instance_crn}`);
    }
    if (response.statusCode === 200)
        return response.body.publicKey;
    else {
        console.error(`Couldn't get the public key for instance ${body.instance_crn} . Reason is: status code ${response.statusCode} and body ${JSON.stringify(response.body)}`);
        throw new Error(`Couldn't get the public key for instance ${body.instance_crn}`);
    }
}

/**
 * Set the challenge TXT record.
 * @param payload
 * @returns {Promise<void>}
 */
async function setChallenge(payload, userInfo) {

    console.log(`Set challenge: '${payload.domain} : ${JSON.stringify(payload.challenge)}`);
    let domain = payload.domain;
    //remove wildcard in case its wildcard certificate.
    domain = domain.replace('*.', '');

    const recordName = payload.challenge.txt_record_name;
    const recordValue = payload.challenge.txt_record_val;

    let zone = await getZoneIdByDomain(domain, userInfo);
    if (!zone || !zone.id) {
        throw `Can't find zone id for domain ${domain}`;
    }
    await addTxtRecord(zone.id, recordName, recordValue, userInfo);
}

/**
 *
 * @param zoneId
 * @param recordName
 * @param recordValue
 * @param userInfo user credentials
 * @returns {Promise<{success: boolean}>}
 */
const addTxtRecord = async (zoneId, recordName, recordValue, userInfo) => {
    console.log(`Add TXT record "${recordValue}" to softlayer zone ${zoneId}`);
    const options = {
        method: 'POST',
        uri: `${softlayerBaseurl}/SoftLayer_Dns_Domain_ResourceRecord`,
        auth: {
            user: userInfo.user,
            pass: userInfo.apiKey
        },
        json: {
            "parameters": [{"host": recordName, "data": recordValue, "ttl": 60, "type": "txt", "domainId": zoneId}]
        }
    };
    let response;
    try {
        response = await request(options);
    }
    catch (err) {
        console.log(`Couldn't add TXT record "${recordValue}" to softlayer zone ${zoneId}. Reason is: ${getErrorString(err)}`);
        throw err;
    }
    if (response.statusCode === 201) {
        console.log(`TXT record "${recordValue}" added to softlayer zone ${zoneId} successfully.`);
        return {success: true}
    }
    else {
        console.log(`Couldn't add TXT record "${recordValue}" to softlayer zone ${zoneId}. Reason is: status code ${response.statusCode} and body ${JSON.stringify(response.body)}`);
        throw response.body;
    }

};

/**
 * Get zone id by domain.
 * @param domainName
 * @param userInfo user credentials
 * @return object {id:zoneId}
 */
const getZoneIdByDomain = async (domainName, userInfo) => {
    const options = {
        method: 'GET',
        uri: `${softlayerBaseurl}/SoftLayer_Dns_Domain/getByDomainName/${encodeURIComponent(domainName)}${encodeURIComponent('.json')}`,
        auth: {
            user: userInfo.user,
            pass: userInfo.apiKey
        }
    };
    let response;
    try {
        response = await request(options);
    }
    catch (err) {
        console.error(`Couldn't get zone for domain "${domainName}" with Error: ${getErrorString(err)}`);
        throw  err;
    }
    if (response.statusCode !== 200) {
        console.error(`Couldn't get zone for domain ${domainName}. Reason is: status code "${response.statusCode}" and body ${JSON.stringify(response.body)}`);
        throw `Fail to get zone for domain "${domainName}"`;
    }
    console.log(`Get zone for domain "${domainName} finished successfully with body: ${JSON.stringify(response.body)}`);
    return {id: response.body.length > 0 ? response.body[0].id : undefined};
};


/**
 * Remove TXT record of challenge
 * @param payload
 * @param userInfo user credentials
 * @returns {Promise<void>}
 */
const removeChallenge = async (payload, userInfo) => {
    let domain = payload.domain;
    //remove wildcard in case its wildcard certificate.
    domain = domain.replace('*.', '');

    const zone = await getZoneIdByDomain(domain);
    if (!zone || !zone.id) {
        throw `Can't find zone id for domain ${domain}`;
    }

    const recordName = payload.challenge.txt_record_name;
    const token = payload.challenge.txt_record_val;

    const options = {
        method: 'GET',
        uri: `${softlayerBaseurl}/SoftLayer_Dns_Domain/${zone.id}/getResourceRecords?objectFilter={"resourceRecords":{"host":{"operation": "${recordName}"},"data":{"operation": "${token}"}}}`,
        auth: {
            user: userInfo.user,
            pass: userInfo.apiKey
        }
    };

    const res = await request(options);

    if (res.statusCode !== 200) {
        const err = `Couldn't get records named ${recordName} with status code ${res.statusCode} and body ${JSON.stringify(res.body)}`;
        console.error(err);
        throw err;
    }

    console.log(`Get records named ${recordName} for domain ${domain} returned with ${res.body.length} results.`);

    await Promise.all(res.body.map(r => removeTxtRecord(r.id, userInfo)));

    console.log(`Remove records for domain ${domain} finished successfully.`)

};


/**
 * Delete single TXT record from soflayer zone.
 * @param recordId
 * @param userInfo user credentials
 * @returns {Promise<void>}
 */
const removeTxtRecord = async (recordId, userInfo) => {
    console.log(`Delete TXT record "${recordId}"`);

    const options = {
        method: 'DELETE',
        uri: `${softlayerBaseurl}/SoftLayer_Dns_Domain_ResourceRecord/${recordId}`,
        auth: {
            user: userInfo.user,
            pass: userInfo.apiKey
        }
    };
    let response;
    try {
        response = await request(options);
    }
    catch (e) {
        console.log(`Delete TXT record "${recordId}" failed with ERR ${getErrorString(e)}`);
        throw e;
    }
    if (response.statusCode === 200) {
        console.log(`Delete TXT record "${recordId}" finished successfully.`);
        return {success: true}
    }
    else {
        console.log(`Delete TXT record "${recordId}" failed with body ${JSON.stringify(response.body)}`);
        throw response.body;
    }

};

/**
 *
 * main() will be run when you invoke this action
 *
 * @param params Cloud Functions actions accept a single parameter, which must be a JSON object.
 *
 * @return The output of this action, which must be a JSON object.
 *
 */
async function main(params) {
    console.log("Cloud function invoked.");
    try {

        const body = jwtDecode(params.data);

        // Validate that the notification was sent from a Certificate Manager instance that has allowed access
        if (!params.allowedCertificateManagerCRNs || !params.allowedCertificateManagerCRNs[body.instance_crn]) {
            console.error(`Certificate Manager instance ${body.instance_crn} is not allowed to invoke this action`);
            return Promise.reject({
                statusCode: 403,
                headers: {'Content-Type': 'application/json'},
                body: {message: 'Unauthorized'},
            });
        }
        const certificateManagerApiUrl = `https://${params.cmRegion}.certificate-manager.cloud.ibm.com`;
        const publicKey = await getPublicKey(body, certificateManagerApiUrl);
        const decodedNotification = await jwtVerify(params.data, publicKey);
        const userInfo = {
            user: params.softlayerUserId,
            apiKey: params.softlayerApiKey
        };

        console.log(`Notification message body: ${JSON.stringify(decodedNotification)}`);
        switch (decodedNotification.event_type) {
            // Handle other certificate manager event types.
            // ...

            // Handling domain validation event types.
            case "cert_domain_validation_required":
                await setChallenge(decodedNotification, userInfo);
                break;
            case "cert_domain_validation_completed":
                await removeChallenge(decodedNotification, userInfo);
                break;
        }
    }
    catch (err) {
        console.log(`Action failed. Reason:${getErrorString(err)}`);
        return Promise.reject({
            statusCode: err.statusCode ? err.statusCode : 500,
            headers: {'Content-Type': 'application/json'},
            body: {message: err.message ? err.message : 'Error processing your request'},
        });
    }
    return {
        statusCode: 200,
        headers: {'Content-Type': 'application/json'},
        body: {}
    };
}

const getErrorString = (error) => {
    if (error)
        return (typeof error.message === 'string') ? error.message : JSON.stringify(error);
    else
        return 'Error undefined';
};


exports.main = main;

const softlayerUserId = 'IBM1308127';
const softlayerApiKey = "dcbc2edbf37d23b38208e53a123911b3279add00b1c4b75715f008eb5788aec0";

main({region: 'us-south', softlayerUserId, softlayerApiKey, data: {}});